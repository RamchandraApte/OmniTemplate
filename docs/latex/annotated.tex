\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{structutility_1_1ar}{utility\+::ar$<$ T $>$}} \\*Array convenience template. Converts C style array type to std\+::array type }{\pageref{structutility_1_1ar}}{}
\item\contentsline{section}{\mbox{\hyperlink{structutility_1_1ar_3_01T_0fn_0e_4}{utility\+::ar$<$ T\mbox{[}n\mbox{]}$>$}} }{\pageref{structutility_1_1ar_3_01T_0fn_0e_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structgraph__theory_1_1BFS}{graph\+\_\+theory\+::\+B\+F\+S$<$ Graph $>$}} \\*Breadth-\/first search }{\pageref{structgraph__theory_1_1BFS}}{}
\item\contentsline{section}{\mbox{\hyperlink{structbigint_1_1BigInt}{bigint\+::\+Big\+Int}} }{\pageref{structbigint_1_1BigInt}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBIT}{B\+I\+T$<$ Value, Monoid\+Op $>$}} \\*Binary indexed tree (also called Fenwick tree) }{\pageref{classBIT}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1bytehash}{string\+\_\+tools\+::bytehash}} }{\pageref{structstring__tools_1_1bytehash}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1bytehash}{string\+\_\+tools\+::bytehash}} }{\pageref{structstring__tools_1_1bytehash}}{}
\item\contentsline{section}{\mbox{\hyperlink{classutility_1_1chained__compare}{utility\+::chained\+\_\+compare$<$ Compare $>$}} }{\pageref{classutility_1_1chained__compare}}{}
\item\contentsline{section}{\mbox{\hyperlink{structconvex__hull__trick_1_1CHT}{convex\+\_\+hull\+\_\+trick\+::\+C\+HT}} }{\pageref{structconvex__hull__trick_1_1CHT}}{}
\item\contentsline{section}{\mbox{\hyperlink{structconvex__hull__trick_1_1CHT}{convex\+\_\+hull\+\_\+trick\+::\+C\+HT}} }{\pageref{structconvex__hull__trick_1_1CHT}}{}
\item\contentsline{section}{\mbox{\hyperlink{structgraph__theory_1_1DFS}{graph\+\_\+theory\+::\+D\+F\+S$<$ Graph $>$}} \\*Depth-\/first search }{\pageref{structgraph__theory_1_1DFS}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsparse__table_1_1DisjointSparseTable}{sparse\+\_\+table\+::\+Disjoint\+Sparse\+Table$<$ T, Monoid $>$}} \\*Disjoint sparse table }{\pageref{classsparse__table_1_1DisjointSparseTable}}{}
\item\contentsline{section}{\mbox{\hyperlink{structdsu__ds_1_1dsu}{dsu\+\_\+ds\+::dsu}} \\*Disjoint-\/set data structure }{\pageref{structdsu__ds_1_1dsu}}{}
\item\contentsline{section}{\mbox{\hyperlink{structdsu__ds_1_1dsu}{dsu\+\_\+ds\+::dsu}} \\*Disjoint-\/set data structure }{\pageref{structdsu__ds_1_1dsu}}{}
\item\contentsline{section}{\mbox{\hyperlink{structgraph__theory_1_1edge}{graph\+\_\+theory\+::edge}} \\*Edge with weight weight from a to b }{\pageref{structgraph__theory_1_1edge}}{}
\item\contentsline{section}{\mbox{\hyperlink{structutility_1_1Empty}{utility\+::\+Empty}} }{\pageref{structutility_1_1Empty}}{}
\item\contentsline{section}{\mbox{\hyperlink{structpersistent_1_1first__cmp}{persistent\+::first\+\_\+cmp}} }{\pageref{structpersistent_1_1first__cmp}}{}
\item\contentsline{section}{\mbox{\hyperlink{structutility_1_1fix}{utility\+::fix$<$ Func $>$}} \\*Helper for lambda recursive functions. The recursive function is passed to Func as the first argument }{\pageref{structutility_1_1fix}}{}
\item\contentsline{section}{\mbox{\hyperlink{structflow_1_1FlowEdge}{flow\+::\+Flow\+Edge}} }{\pageref{structflow_1_1FlowEdge}}{}
\item\contentsline{section}{\mbox{\hyperlink{structgraph__theory_1_1GeneralSearch}{graph\+\_\+theory\+::\+General\+Search$<$ Searcher, Graph $>$}} \\*Generalized graph searcher/visitor }{\pageref{structgraph__theory_1_1GeneralSearch}}{}
\item\contentsline{section}{\mbox{\hyperlink{structgraph__theory_1_1GraphAdj}{graph\+\_\+theory\+::\+Graph\+Adj}} }{\pageref{structgraph__theory_1_1GraphAdj}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1hash_3_01ll_01_4}{std\+::hash$<$ ll $>$}} }{\pageref{structstd_1_1hash_3_01ll_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1hash_3_01modulo_01_4}{std\+::hash$<$ modulo $>$}} }{\pageref{structstd_1_1hash_3_01modulo_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1hash__str}{string\+\_\+tools\+::hash\+\_\+str}} }{\pageref{structstring__tools_1_1hash__str}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1hash__str}{string\+\_\+tools\+::hash\+\_\+str}} }{\pageref{structstring__tools_1_1hash__str}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhld_1_1HLD}{hld\+::\+H\+L\+D$<$ T, Monoid, Query\+D\+S $>$}} \\*Heavy-\/light decomposition }{\pageref{classhld_1_1HLD}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhld_1_1HLD}{hld\+::\+H\+L\+D$<$ T, Monoid, Query\+D\+S $>$}} \\*Heavy-\/light decomposition }{\pageref{classhld_1_1HLD}}{}
\item\contentsline{section}{\mbox{\hyperlink{structint__it}{int\+\_\+it$<$ T $>$}} }{\pageref{structint__it}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1is__integral_3_01ll_01_4}{std\+::is\+\_\+integral$<$ ll $>$}} }{\pageref{structstd_1_1is__integral_3_01ll_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1is__signed_3_01ll_01_4}{std\+::is\+\_\+signed$<$ ll $>$}} }{\pageref{structstd_1_1is__signed_3_01ll_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1is__unsigned_3_01ll_01_4}{std\+::is\+\_\+unsigned$<$ ll $>$}} }{\pageref{structstd_1_1is__unsigned_3_01ll_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structit__base}{it\+\_\+base$<$ T $>$}} }{\pageref{structit__base}}{}
\item\contentsline{section}{\mbox{\hyperlink{structSubgraph_1_1iterator}{Subgraph$<$ Graph, Pred $>$\+::iterator}} }{\pageref{structSubgraph_1_1iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsplay__tree_1_1SplayTree_1_1iterator}{splay\+\_\+tree\+::\+Splay\+Tree$<$ T $>$\+::iterator}} \\*Splay tree node }{\pageref{structsplay__tree_1_1SplayTree_1_1iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsegment__tree_1_1SegmentTree_1_1LazyPart}{segment\+\_\+tree\+::\+Segment\+Tree$<$ T, Query, Update, has\+\_\+lazy, has\+\_\+ptr, has\+\_\+pers, base $>$\+::\+Lazy\+Part}} }{\pageref{structsegment__tree_1_1SegmentTree_1_1LazyPart}}{}
\item\contentsline{section}{\mbox{\hyperlink{structlets__add}{lets\+\_\+add}} }{\pageref{structlets__add}}{}
\item\contentsline{section}{\mbox{\hyperlink{structll}{ll}} }{\pageref{structll}}{}
\item\contentsline{section}{\mbox{\hyperlink{structlinear__algebra_1_1matrix}{linear\+\_\+algebra\+::matrix$<$ T $>$}} }{\pageref{structlinear__algebra_1_1matrix}}{}
\item\contentsline{section}{\mbox{\hyperlink{structlinear__algebra_1_1matrix}{linear\+\_\+algebra\+::matrix$<$ T $>$}} }{\pageref{structlinear__algebra_1_1matrix}}{}
\item\contentsline{section}{\mbox{\hyperlink{structMax}{Max}} }{\pageref{structMax}}{}
\item\contentsline{section}{\mbox{\hyperlink{structMin}{Min}} }{\pageref{structMin}}{}
\item\contentsline{section}{\mbox{\hyperlink{classqueue__tools_1_1MinQueue}{queue\+\_\+tools\+::\+Min\+Queue$<$ T $>$}} }{\pageref{classqueue__tools_1_1MinQueue}}{}
\item\contentsline{section}{\mbox{\hyperlink{classqueue__tools_1_1MinQueue}{queue\+\_\+tools\+::\+Min\+Queue$<$ T $>$}} }{\pageref{classqueue__tools_1_1MinQueue}}{}
\item\contentsline{section}{\mbox{\hyperlink{classqueue__tools_1_1MinStack}{queue\+\_\+tools\+::\+Min\+Stack$<$ T, Base $>$}} }{\pageref{classqueue__tools_1_1MinStack}}{}
\item\contentsline{section}{\mbox{\hyperlink{classqueue__tools_1_1MinStack}{queue\+\_\+tools\+::\+Min\+Stack$<$ T, Base $>$}} }{\pageref{classqueue__tools_1_1MinStack}}{}
\item\contentsline{section}{\mbox{\hyperlink{structmodulo__namespace_1_1modulo}{modulo\+\_\+namespace\+::modulo}} }{\pageref{structmodulo__namespace_1_1modulo}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtree_1_1no}{tree\+::no$<$ T $>$}} }{\pageref{structtree_1_1no}}{}
\item\contentsline{section}{\mbox{\hyperlink{structmodulo__namespace_1_1no__mod}{modulo\+\_\+namespace\+::no\+\_\+mod}} }{\pageref{structmodulo__namespace_1_1no__mod}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsegment__tree_1_1SegmentTree_1_1NodeCore}{segment\+\_\+tree\+::\+Segment\+Tree$<$ T, Query, Update, has\+\_\+lazy, has\+\_\+ptr, has\+\_\+pers, base $>$\+::\+Node\+Core}} }{\pageref{structsegment__tree_1_1SegmentTree_1_1NodeCore}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsegment__tree_1_1SegmentTree_1_1NodeExp}{segment\+\_\+tree\+::\+Segment\+Tree$<$ T, Query, Update, has\+\_\+lazy, has\+\_\+ptr, has\+\_\+pers, base $>$\+::\+Node\+Exp}} }{\pageref{structsegment__tree_1_1SegmentTree_1_1NodeExp}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1numeric__limits_3_01ll_01_4}{std\+::numeric\+\_\+limits$<$ ll $>$}} }{\pageref{structstd_1_1numeric__limits_3_01ll_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsplay__tree_1_1PathParent}{splay\+\_\+tree\+::\+Path\+Parent$<$ Node $>$}} \\*Implements a splay tree }{\pageref{structsplay__tree_1_1PathParent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classpermutation_1_1Permutation}{permutation\+::\+Permutation}} \\*\mbox{\hyperlink{classpermutation_1_1Permutation}{Permutation}} class }{\pageref{classpermutation_1_1Permutation}}{}
\item\contentsline{section}{\mbox{\hyperlink{structpersistent_1_1pers}{persistent\+::pers$<$ T $>$}} }{\pageref{structpersistent_1_1pers}}{}
\item\contentsline{section}{\mbox{\hyperlink{classpolynomial__ns_1_1Polynomial}{polynomial\+\_\+ns\+::\+Polynomial$<$ T $>$}} }{\pageref{classpolynomial__ns_1_1Polynomial}}{}
\item\contentsline{section}{\mbox{\hyperlink{classqueue__tools_1_1QueueAdaptor}{queue\+\_\+tools\+::\+Queue\+Adaptor$<$ Stack $>$}} \\*Queue adaptor, creates a queue using two Stacks left, right If there are at least two elements, left and right are not empty }{\pageref{classqueue__tools_1_1QueueAdaptor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classqueue__tools_1_1QueueAdaptor}{queue\+\_\+tools\+::\+Queue\+Adaptor$<$ Stack $>$}} \\*Queue adaptor, creates a queue using two Stacks left, right If there are at least two elements, left and right are not empty }{\pageref{classqueue__tools_1_1QueueAdaptor}}{}
\item\contentsline{section}{\mbox{\hyperlink{structutility_1_1random__device__patch}{utility\+::random\+\_\+device\+\_\+patch}} \\*Random device patch to fix libstdc++\textquotesingle{}s broken implementation on Windows }{\pageref{structutility_1_1random__device__patch}}{}
\item\contentsline{section}{\mbox{\hyperlink{structrange}{range$<$ T $>$}} }{\pageref{structrange}}{}
\item\contentsline{section}{\mbox{\hyperlink{structrin}{rin}} }{\pageref{structrin}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1search__it}{string\+\_\+tools\+::search\+\_\+it}} \\*Search iterator for looping through all matches of a string s in t using K\+MP. Complexity\+: $O(n)$, where is the length between subsequent matches }{\pageref{structstring__tools_1_1search__it}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1search__it}{string\+\_\+tools\+::search\+\_\+it}} \\*Search iterator for looping through all matches of a string s in t using K\+MP. Complexity\+: $O(n)$, where is the length between subsequent matches }{\pageref{structstring__tools_1_1search__it}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsegment__tree_1_1SegmentTree}{segment\+\_\+tree\+::\+Segment\+Tree$<$ T, Query, Update, has\+\_\+lazy, has\+\_\+ptr, has\+\_\+pers, base $>$}} \\*Generic persistent explicit/implicit lazy based segment tree, technically known as range query tree }{\pageref{classsegment__tree_1_1SegmentTree}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsegment__tree_1_1SegmentTree}{segment\+\_\+tree\+::\+Segment\+Tree$<$ T, Query, Update, has\+\_\+lazy, has\+\_\+ptr, has\+\_\+pers, base $>$}} \\*Generic persistent explicit/implicit lazy based segment tree, technically known as range query tree }{\pageref{classsegment__tree_1_1SegmentTree}}{}
\item\contentsline{section}{\mbox{\hyperlink{structset__multitest}{set\+\_\+multitest}} }{\pageref{structset__multitest}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsize__data}{size\+\_\+data$<$ Key $>$}} }{\pageref{structsize__data}}{}
\item\contentsline{section}{\mbox{\hyperlink{classsparse__table_1_1SparseTable}{sparse\+\_\+table\+::\+Sparse\+Table$<$ T, Semilattice $>$}} }{\pageref{classsparse__table_1_1SparseTable}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsplay__tree_1_1SplayNode}{splay\+\_\+tree\+::\+Splay\+Node$<$ T, has\+\_\+link\+\_\+cut $>$}} }{\pageref{structsplay__tree_1_1SplayNode}}{}
\item\contentsline{section}{\mbox{\hyperlink{structsplay__tree_1_1SplayTree}{splay\+\_\+tree\+::\+Splay\+Tree$<$ T $>$}} }{\pageref{structsplay__tree_1_1SplayTree}}{}
\item\contentsline{section}{\mbox{\hyperlink{structSubgraph}{Subgraph$<$ Graph, Pred $>$}} \\*Filters graph by a predicate }{\pageref{structSubgraph}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtime__tools_1_1timer}{time\+\_\+tools\+::timer}} }{\pageref{structtime__tools_1_1timer}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtreap}{treap$<$ Key, Data $>$}} }{\pageref{structtreap}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1Trie}{string\+\_\+tools\+::\+Trie$<$ start, alphabet\+\_\+size $>$}} }{\pageref{structstring__tools_1_1Trie}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstring__tools_1_1Trie}{string\+\_\+tools\+::\+Trie$<$ start, alphabet\+\_\+size $>$}} }{\pageref{structstring__tools_1_1Trie}}{}
\item\contentsline{section}{\mbox{\hyperlink{structutility_1_1with}{utility\+::with$<$ T $>$}} \\*Sets v to new\+\_\+ temporary while with object is alive }{\pageref{structutility_1_1with}}{}
\end{DoxyCompactList}
